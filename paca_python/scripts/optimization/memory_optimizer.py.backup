"""
Phase 9.3: 메모리 및 리소스 최적화
PACA 시스템의 메모리 사용량 최적화 및 리소스 효율성 개선
"""

import asyncio
import sys
import os
import time
import json
import gc
import tracemalloc
import weakref
import psutil
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from collections import defaultdict

# PACA 모듈 경로 추가
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))

from paca.tools import (
    ReActFramework, PACAToolManager, SafetyPolicy
)
from paca.tools.tools import WebSearchTool, FileManagerTool


@dataclass
class MemorySnapshot:
    """메모리 스냅샷 데이터"""
    timestamp: float
    current_memory: float  # MB
    peak_memory: float     # MB
    object_count: int
    gc_stats: Dict[str, Any]
    process_memory: float  # MB


@dataclass
class ResourceUsage:
    """리소스 사용량 데이터"""
    cpu_percent: float
    memory_percent: float
    disk_io_read: float
    disk_io_write: float
    network_io_sent: float
    network_io_recv: float


class MemoryOptimizer:
    """PACA 시스템 메모리 및 리소스 최적화 클래스"""

    def __init__(self):
        self.components = {}
        self.memory_snapshots = []
        self.resource_usage_history = []
        self.optimization_results = {}

    async def setup_monitoring(self):
        """모니터링 환경 설정"""
        print("=== 메모리 최적화 환경 설정 ===")

        try:
            # 메모리 추적 시작
            tracemalloc.start()

            # 가비지 컬렉션 설정
            gc.set_debug(gc.DEBUG_STATS)
            gc.collect()

            # 컴포넌트 초기화
            self.components['tool_manager'] = PACAToolManager()
            self.components['web_search'] = WebSearchTool()
            self.components['file_manager'] = FileManagerTool()
            self.components['react_framework'] = ReActFramework(self.components['tool_manager'])

            # 도구 등록
            self.components['tool_manager'].register_tool(self.components['web_search'])
            self.components['tool_manager'].register_tool(self.components['file_manager'])

            # 초기 메모리 스냅샷
            await self.take_memory_snapshot("initial")

            print("메모리 모니터링 환경 설정 완료")
            return True

        except Exception as e:
            print(f"환경 설정 실패: {e}")
            return False

    async def take_memory_snapshot(self, label: str = ""):
        """메모리 스냅샷 생성"""
        try:
            # tracemalloc 정보
            current, peak = tracemalloc.get_traced_memory()

            # 프로세스 메모리 정보
            process = psutil.Process()
            process_memory = process.memory_info().rss / 1024 / 1024  # MB

            # 객체 수 계산
            object_count = len(gc.get_objects())

            # GC 통계
            gc_stats = {
                'collections': gc.get_stats(),
                'counts': gc.get_count(),
                'threshold': gc.get_threshold()
            }

            snapshot = MemorySnapshot(
                timestamp=time.time(),
                current_memory=current / 1024 / 1024,  # MB
                peak_memory=peak / 1024 / 1024,        # MB
                object_count=object_count,
                gc_stats=gc_stats,
                process_memory=process_memory
            )

            self.memory_snapshots.append((label, snapshot))

            print(f"   [{label}] 메모리: {snapshot.current_memory:.2f}MB, 객체: {snapshot.object_count}개")
            return snapshot

        except Exception as e:
            print(f"메모리 스냅샷 실패: {e}")
            return None

    async def measure_resource_usage(self, duration: float = 1.0):
        """리소스 사용량 측정"""
        try:
            process = psutil.Process()

            # 초기 측정
            cpu_times_start = process.cpu_times()
            io_start = process.io_counters()
            net_start = psutil.net_io_counters()

            # 지정된 시간 대기
            await asyncio.sleep(duration)

            # 종료 측정
            cpu_percent = process.cpu_percent()
            memory_info = process.memory_info()
            io_end = process.io_counters()
            net_end = psutil.net_io_counters()

            # 계산
            disk_io_read = (io_end.read_bytes - io_start.read_bytes) / 1024 / 1024  # MB
            disk_io_write = (io_end.write_bytes - io_start.write_bytes) / 1024 / 1024  # MB
            network_sent = (net_end.bytes_sent - net_start.bytes_sent) / 1024 / 1024  # MB
            network_recv = (net_end.bytes_recv - net_start.bytes_recv) / 1024 / 1024  # MB

            usage = ResourceUsage(
                cpu_percent=cpu_percent,
                memory_percent=psutil.virtual_memory().percent,
                disk_io_read=disk_io_read,
                disk_io_write=disk_io_write,
                network_io_sent=network_sent,
                network_io_recv=network_recv
            )

            self.resource_usage_history.append((time.time(), usage))
            return usage

        except Exception as e:
            print(f"리소스 측정 실패: {e}")
            return None

    async def test_memory_intensive_operations(self):
        """메모리 집약적 작업 테스트"""
        print("\n=== 메모리 집약적 작업 테스트 ===")

        results = {}

        # 1. 대량 웹 검색 테스트
        print("1. 대량 웹 검색 메모리 테스트...")
        await self.take_memory_snapshot("before_web_search")

        search_count = 10
        search_results = []

        for i in range(search_count):
            try:
                result = await self.components['tool_manager'].execute_tool(
                    'web_search',
                    query=f'memory test query {i}'
                )
                search_results.append(result)

                # 주기적으로 메모리 체크
                if i % 3 == 0:
                    await self.take_memory_snapshot(f"web_search_{i}")

            except Exception as e:
                print(f"   검색 {i} 실패: {e}")

        await self.take_memory_snapshot("after_web_search")

        results['web_search_test'] = {
            'search_count': search_count,
            'successful_searches': len([r for r in search_results if r.success]),
            'memory_snapshots': len([s for s in self.memory_snapshots if 'web_search' in s[0]])
        }

        # 2. 대량 파일 작업 테스트
        print("2. 대량 파일 작업 메모리 테스트...")
        await self.take_memory_snapshot("before_file_operations")

        file_count = 20
        file_results = []

        for i in range(file_count):
            try:
                # 파일 생성
                content = f"Memory test file content {i} " * 100  # 약간 큰 내용
                result = await self.components['tool_manager'].execute_tool(
                    'file_manager',
                    operation='write',
                    path=f'memory_test_{i}.txt',
                    content=content
                )
                file_results.append(result)

                # 주기적으로 가비지 컬렉션
                if i % 5 == 0:
                    gc.collect()
                    await self.take_memory_snapshot(f"file_ops_{i}")

            except Exception as e:
                print(f"   파일 작업 {i} 실패: {e}")

        await self.take_memory_snapshot("after_file_operations")

        results['file_operations_test'] = {
            'file_count': file_count,
            'successful_operations': len([r for r in file_results if r.success]),
            'memory_snapshots': len([s for s in self.memory_snapshots if 'file_ops' in s[0]])
        }

        # 3. ReAct 세션 스트레스 테스트
        print("3. ReAct 세션 메모리 테스트...")
        await self.take_memory_snapshot("before_react_sessions")

        session_count = 5
        sessions = []

        for i in range(session_count):
            try:
                session = await self.components['react_framework'].create_session(
                    goal=f"메모리 테스트 세션 {i}",
                    max_steps=3
                )

                # 몇 가지 단계 실행
                await self.components['react_framework'].think(
                    session,
                    f"메모리 테스트 {i}를 위한 생각"
                )

                sessions.append(session)

                if i % 2 == 0:
                    await self.take_memory_snapshot(f"react_session_{i}")

            except Exception as e:
                print(f"   세션 {i} 실패: {e}")

        await self.take_memory_snapshot("after_react_sessions")

        results['react_sessions_test'] = {
            'session_count': session_count,
            'successful_sessions': len(sessions),
            'total_steps': sum(len(s.steps) for s in sessions)
        }

        return results

    def analyze_memory_patterns(self):
        """메모리 사용 패턴 분석"""
        print("\n=== 메모리 사용 패턴 분석 ===")

        if len(self.memory_snapshots) < 2:
            return {'error': '충분한 메모리 스냅샷이 없습니다'}

        analysis = {
            'memory_growth': {},
            'peak_usage': {},
            'object_growth': {},
            'gc_performance': {},
            'optimization_opportunities': []
        }

        # 메모리 증가 패턴 분석
        initial_snapshot = self.memory_snapshots[0][1]
        final_snapshot = self.memory_snapshots[-1][1]

        total_memory_growth = final_snapshot.current_memory - initial_snapshot.current_memory
        total_object_growth = final_snapshot.object_count - initial_snapshot.object_count

        analysis['memory_growth'] = {
            'total_mb': total_memory_growth,
            'peak_mb': max(s[1].peak_memory for s in self.memory_snapshots),
            'avg_mb': sum(s[1].current_memory for s in self.memory_snapshots) / len(self.memory_snapshots)
        }

        analysis['object_growth'] = {
            'total_objects': total_object_growth,
            'growth_rate': total_object_growth / len(self.memory_snapshots) if self.memory_snapshots else 0
        }

        # 피크 사용량 분석
        peak_snapshot = max(self.memory_snapshots, key=lambda x: x[1].current_memory)
        analysis['peak_usage'] = {
            'phase': peak_snapshot[0],
            'memory_mb': peak_snapshot[1].current_memory,
            'object_count': peak_snapshot[1].object_count
        }

        # 최적화 기회 식별
        if total_memory_growth > 50:  # 50MB 이상 증가
            analysis['optimization_opportunities'].append({
                'type': 'memory_leak_potential',
                'description': f'메모리 사용량이 {total_memory_growth:.1f}MB 증가',
                'recommendation': '메모리 누수 검사, 객체 생명주기 검토'
            })

        if total_object_growth > 1000:  # 1000개 이상 객체 증가
            analysis['optimization_opportunities'].append({
                'type': 'object_proliferation',
                'description': f'객체 수가 {total_object_growth}개 증가',
                'recommendation': '객체 풀링, 약한 참조 사용 검토'
            })

        # GC 성능 분석
        gc_collections = sum(
            sum(gen['collections'] for gen in snapshot[1].gc_stats['collections'])
            for snapshot in self.memory_snapshots
        )

        analysis['gc_performance'] = {
            'total_collections': gc_collections,
            'avg_collections_per_snapshot': gc_collections / len(self.memory_snapshots) if self.memory_snapshots else 0
        }

        if gc_collections > len(self.memory_snapshots) * 5:  # 스냅샷당 5회 이상 GC
            analysis['optimization_opportunities'].append({
                'type': 'excessive_gc',
                'description': f'GC가 {gc_collections}회 실행됨',
                'recommendation': 'GC 임계값 조정, 객체 생성 패턴 최적화'
            })

        print(f"   메모리 증가: {total_memory_growth:.1f}MB")
        print(f"   피크 사용량: {analysis['peak_usage']['memory_mb']:.1f}MB ({analysis['peak_usage']['phase']})")
        print(f"   객체 증가: {total_object_growth}개")
        print(f"   최적화 기회: {len(analysis['optimization_opportunities'])}개")

        return analysis

    async def implement_optimizations(self):
        """메모리 최적화 구현"""
        print("\n=== 메모리 최적화 구현 ===")

        optimizations = {}

        # 1. 가비지 컬렉션 최적화
        print("1. 가비지 컬렉션 최적화...")
        try:
            # GC 임계값 조정
            old_thresholds = gc.get_threshold()
            new_thresholds = (700, 10, 10)  # 기본값보다 더 자주 실행
            gc.set_threshold(*new_thresholds)

            # 강제 가비지 컬렉션
            collected_objects = gc.collect()

            optimizations['gc_optimization'] = {
                'old_thresholds': old_thresholds,
                'new_thresholds': new_thresholds,
                'collected_objects': collected_objects,
                'status': 'applied'
            }

            print(f"   GC 임계값 조정: {old_thresholds} -> {new_thresholds}")
            print(f"   수집된 객체: {collected_objects}개")

        except Exception as e:
            optimizations['gc_optimization'] = {'status': 'failed', 'error': str(e)}

        # 2. 약한 참조 적용 (시뮬레이션)
        print("2. 약한 참조 최적화...")
        try:
            # 컴포넌트에 약한 참조 적용 (시뮬레이션)
            weak_refs = {}
            for name, component in self.components.items():
                try:
                    weak_refs[name] = weakref.ref(component)
                except TypeError:
                    # 약한 참조를 지원하지 않는 객체
                    weak_refs[name] = None

            valid_weak_refs = sum(1 for ref in weak_refs.values() if ref is not None)

            optimizations['weak_reference_optimization'] = {
                'total_components': len(self.components),
                'weak_refs_created': valid_weak_refs,
                'status': 'simulated'
            }

            print(f"   약한 참조 생성: {valid_weak_refs}/{len(self.components)}개 컴포넌트")

        except Exception as e:
            optimizations['weak_reference_optimization'] = {'status': 'failed', 'error': str(e)}

        # 3. 메모리 풀 시뮬레이션
        print("3. 메모리 풀 최적화...")
        try:
            # 간단한 메모리 풀 시뮬레이션
            memory_pool = {
                'small_objects': [],  # < 1KB
                'medium_objects': [], # 1KB - 100KB
                'large_objects': []   # > 100KB
            }

            # 가상의 객체 할당/해제 시뮬레이션
            for i in range(100):
                obj_size = i * 10  # 가상 크기
                if obj_size < 1024:
                    memory_pool['small_objects'].append(f'obj_{i}')
                elif obj_size < 102400:
                    memory_pool['medium_objects'].append(f'obj_{i}')
                else:
                    memory_pool['large_objects'].append(f'obj_{i}')

            optimizations['memory_pool_optimization'] = {
                'small_pool_size': len(memory_pool['small_objects']),
                'medium_pool_size': len(memory_pool['medium_objects']),
                'large_pool_size': len(memory_pool['large_objects']),
                'status': 'simulated'
            }

            print(f"   메모리 풀 생성: {sum(len(pool) for pool in memory_pool.values())}개 객체")

        except Exception as e:
            optimizations['memory_pool_optimization'] = {'status': 'failed', 'error': str(e)}

        return optimizations

    async def measure_optimization_effectiveness(self):
        """최적화 효과 측정"""
        print("\n=== 최적화 효과 측정 ===")

        # 최적화 후 메모리 스냅샷
        await self.take_memory_snapshot("after_optimization")

        # 최적화 후 간단한 작업 수행
        print("최적화 효과 확인을 위한 테스트 작업 수행...")

        try:
            # 웹 검색 테스트
            result = await self.components['tool_manager'].execute_tool(
                'web_search',
                query='optimization effectiveness test'
            )

            # 파일 작업 테스트
            await self.components['tool_manager'].execute_tool(
                'file_manager',
                operation='write',
                path='optimization_test.txt',
                content='Optimization effectiveness test'
            )

            # ReAct 세션 테스트
            session = await self.components['react_framework'].create_session(
                goal="최적화 효과 테스트",
                max_steps=2
            )

            await self.components['react_framework'].think(
                session,
                "최적화 효과를 확인하고 있습니다."
            )

        except Exception as e:
            print(f"   테스트 작업 중 오류: {e}")

        # 최종 메모리 스냅샷
        await self.take_memory_snapshot("final_measurement")

        # 효과 분석
        if len(self.memory_snapshots) >= 3:
            before_opt = next((s[1] for s in self.memory_snapshots if s[0] == "after_react_sessions"), None)
            after_opt = next((s[1] for s in self.memory_snapshots if s[0] == "after_optimization"), None)
            final = next((s[1] for s in self.memory_snapshots if s[0] == "final_measurement"), None)

            if before_opt and after_opt and final:
                effectiveness = {
                    'memory_reduction': before_opt.current_memory - after_opt.current_memory,
                    'object_reduction': before_opt.object_count - after_opt.object_count,
                    'stability_check': abs(final.current_memory - after_opt.current_memory) < 5.0,  # 5MB 이하 변동
                    'optimization_maintained': final.current_memory <= after_opt.current_memory * 1.1  # 10% 이하 증가
                }

                print(f"   메모리 감소: {effectiveness['memory_reduction']:.2f}MB")
                print(f"   객체 감소: {effectiveness['object_reduction']}개")
                print(f"   안정성: {'양호' if effectiveness['stability_check'] else '주의 필요'}")

                return effectiveness

        return {'status': 'insufficient_data'}

    async def generate_optimization_report(self):
        """최적화 보고서 생성"""
        print("\n=== 최적화 보고서 생성 ===")

        # 모든 단계 실행
        memory_test_results = await self.test_memory_intensive_operations()
        memory_analysis = self.analyze_memory_patterns()
        optimizations = await self.implement_optimizations()
        effectiveness = await self.measure_optimization_effectiveness()

        # 보고서 작성
        report = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'phase': 'Phase 9.3 - 메모리 및 리소스 최적화',
            'memory_test_results': memory_test_results,
            'memory_analysis': memory_analysis,
            'optimizations_applied': optimizations,
            'optimization_effectiveness': effectiveness,
            'memory_snapshots_count': len(self.memory_snapshots),
            'resource_measurements': len(self.resource_usage_history),
            'summary': {
                'memory_growth_mb': memory_analysis.get('memory_growth', {}).get('total_mb', 0),
                'peak_memory_mb': memory_analysis.get('memory_growth', {}).get('peak_mb', 0),
                'optimizations_successful': sum(1 for opt in optimizations.values() if opt.get('status') in ['applied', 'simulated']),
                'optimization_opportunities': len(memory_analysis.get('optimization_opportunities', [])),
                'effectiveness_confirmed': effectiveness.get('optimization_maintained', False) if isinstance(effectiveness, dict) else False
            },
            'recommendations': self._generate_optimization_recommendations(memory_analysis, effectiveness)
        }

        return report

    def _generate_optimization_recommendations(self, memory_analysis, effectiveness):
        """최적화 권장사항 생성"""
        recommendations = []

        # 메모리 분석 기반 권장사항
        if memory_analysis.get('optimization_opportunities'):
            for opportunity in memory_analysis['optimization_opportunities']:
                recommendations.append({
                    'category': opportunity['type'],
                    'priority': 'high' if 'leak' in opportunity['type'] else 'medium',
                    'description': opportunity['description'],
                    'action': opportunity['recommendation']
                })

        # 효과성 기반 권장사항
        if isinstance(effectiveness, dict) and effectiveness.get('optimization_maintained'):
            recommendations.append({
                'category': 'maintenance',
                'priority': 'low',
                'description': '최적화 효과가 확인됨',
                'action': '현재 최적화 설정 유지, 정기적 모니터링'
            })

        # 일반적 권장사항
        recommendations.extend([
            {
                'category': 'monitoring',
                'priority': 'medium',
                'description': '지속적인 메모리 모니터링 필요',
                'action': '메모리 사용량 추적 시스템 구축'
            },
            {
                'category': 'next_phase',
                'priority': 'low',
                'description': 'Phase 9.4 안정성 강화 준비',
                'action': '에러 처리 및 안정성 검증 계획 수립'
            }
        ])

        return recommendations


async def main():
    """메인 실행 함수"""
    print("PACA Phase 9.3: 메모리 및 리소스 최적화")
    print("=" * 60)

    optimizer = MemoryOptimizer()

    try:
        # 1. 모니터링 환경 설정
        if not await optimizer.setup_monitoring():
            print("모니터링 환경 설정 실패")
            return False

        # 2. 최적화 보고서 생성
        report = await optimizer.generate_optimization_report()

        # 3. 결과 출력
        print(f"\n메모리 최적화 결과:")
        print(f"   메모리 증가량: {report['summary']['memory_growth_mb']:.1f}MB")
        print(f"   피크 메모리: {report['summary']['peak_memory_mb']:.1f}MB")
        print(f"   적용된 최적화: {report['summary']['optimizations_successful']}개")
        print(f"   최적화 기회: {report['summary']['optimization_opportunities']}개")
        print(f"   최적화 효과: {'확인됨' if report['summary']['effectiveness_confirmed'] else '추가 검증 필요'}")

        if report['recommendations']:
            print(f"\n권장사항:")
            high_priority = [r for r in report['recommendations'] if r['priority'] == 'high']
            if high_priority:
                print("   [높은 우선순위]")
                for rec in high_priority:
                    print(f"     - {rec['description']}")
                    print(f"       조치: {rec['action']}")

        print(f"\n다음 단계: Phase 9.4 안정성 강화 및 에러 처리 개선")

        # 4. 보고서 파일 저장
        report_file = "memory_optimization_report.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, ensure_ascii=False, indent=2)

        print(f"\n메모리 최적화 완료! 상세 보고서: {report_file}")
        return True

    except Exception as e:
        print(f"메모리 최적화 실패: {e}")
        import traceback
        traceback.print_exc()
        return False

    finally:
        # 메모리 추적 정리
        try:
            tracemalloc.stop()
        except:
            pass


if __name__ == "__main__":
    success = asyncio.run(main())
    sys.exit(0 if success else 1)