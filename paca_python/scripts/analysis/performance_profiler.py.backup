"""
Phase 9.2: 성능 프로파일링 및 병목점 해결
PACA 시스템의 상세한 성능 분석과 최적화
"""

import asyncio
import sys
import os
import time
import json
import tracemalloc
import cProfile
import pstats
import io
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, List, Any, Optional
import gc
import psutil

# PACA 모듈 경로 추가
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))

from paca.tools import (
    ReActFramework, PACAToolManager, SafetyPolicy
)
from paca.tools.tools import WebSearchTool, FileManagerTool


@dataclass
class PerformanceMetric:
    """성능 메트릭 데이터 클래스"""
    operation: str
    execution_time: float
    memory_usage: float
    cpu_usage: Optional[float] = None
    success: bool = True
    error_message: Optional[str] = None
    iterations: int = 1


@dataclass
class BottleneckAnalysis:
    """병목점 분석 결과"""
    component: str
    operation: str
    issue_type: str  # 'memory', 'cpu', 'io', 'network'
    severity: str    # 'low', 'medium', 'high', 'critical'
    impact_score: float  # 0.0 - 1.0
    recommendation: str
    estimated_improvement: str


class PerformanceProfiler:
    """PACA 시스템 성능 프로파일러"""

    def __init__(self):
        self.components = {}
        self.metrics = []
        self.bottlenecks = []
        self.baseline_metrics = {}

    async def setup_profiling_environment(self):
        """프로파일링 환경 설정"""
        print("=== 성능 프로파일링 환경 설정 ===")

        try:
            # 가비지 컬렉션 활성화
            gc.enable()
            gc.collect()

            # 메모리 추적 시작
            tracemalloc.start()

            # 컴포넌트 초기화
            self.components['tool_manager'] = PACAToolManager()
            self.components['web_search'] = WebSearchTool()
            self.components['file_manager'] = FileManagerTool()
            self.components['react_framework'] = ReActFramework(self.components['tool_manager'])

            # 도구 등록
            self.components['tool_manager'].register_tool(self.components['web_search'])
            self.components['tool_manager'].register_tool(self.components['file_manager'])

            print("프로파일링 환경 설정 완료")
            return True

        except Exception as e:
            print(f"프로파일링 환경 설정 실패: {e}")
            return False

    async def profile_component_startup(self):
        """컴포넌트 시작 시간 프로파일링"""
        print("\n=== 컴포넌트 시작 시간 프로파일링 ===")

        startup_metrics = []

        component_classes = [
            ('PACAToolManager', PACAToolManager),
            ('WebSearchTool', WebSearchTool),
            ('FileManagerTool', FileManagerTool)
        ]

        for name, component_class in component_classes:
            try:
                # 메모리 사용량 측정 시작
                process = psutil.Process()
                start_memory = process.memory_info().rss / 1024 / 1024  # MB

                # 시작 시간 측정
                start_time = time.time()
                component = component_class()
                end_time = time.time()

                # 메모리 사용량 측정 종료
                end_memory = process.memory_info().rss / 1024 / 1024  # MB

                metric = PerformanceMetric(
                    operation=f"{name}_startup",
                    execution_time=end_time - start_time,
                    memory_usage=end_memory - start_memory,
                    success=True
                )

                startup_metrics.append(metric)
                print(f"   {name}: {metric.execution_time:.3f}초, {metric.memory_usage:.2f}MB")

            except Exception as e:
                metric = PerformanceMetric(
                    operation=f"{name}_startup",
                    execution_time=0,
                    memory_usage=0,
                    success=False,
                    error_message=str(e)
                )
                startup_metrics.append(metric)

        return startup_metrics

    async def profile_tool_operations(self, iterations: int = 5):
        """도구 연산 성능 프로파일링"""
        print(f"\n=== 도구 연산 성능 프로파일링 ({iterations}회 반복) ===")

        operation_metrics = []

        # 테스트할 연산들
        operations = [
            {
                'name': 'web_search_small',
                'tool': 'web_search',
                'params': {'query': 'Python'}
            },
            {
                'name': 'web_search_medium',
                'tool': 'web_search',
                'params': {'query': 'Python programming language features'}
            },
            {
                'name': 'file_write_small',
                'tool': 'file_manager',
                'params': {'operation': 'write', 'path': 'test_small.txt', 'content': 'small content'}
            },
            {
                'name': 'file_write_large',
                'tool': 'file_manager',
                'params': {'operation': 'write', 'path': 'test_large.txt', 'content': 'large content ' * 1000}
            },
            {
                'name': 'file_read_operations',
                'tool': 'file_manager',
                'params': {'operation': 'read', 'path': 'test_small.txt'}
            }
        ]

        for operation in operations:
            print(f"   테스트 중: {operation['name']}")

            execution_times = []
            memory_usages = []
            success_count = 0

            for i in range(iterations):
                try:
                    # 메모리 측정 시작
                    process = psutil.Process()
                    start_memory = process.memory_info().rss / 1024 / 1024

                    # 실행 시간 측정
                    start_time = time.time()
                    result = await self.components['tool_manager'].execute_tool(
                        operation['tool'],
                        **operation['params']
                    )
                    end_time = time.time()

                    # 메모리 측정 종료
                    end_memory = process.memory_info().rss / 1024 / 1024

                    execution_times.append(end_time - start_time)
                    memory_usages.append(end_memory - start_memory)

                    if result.success:
                        success_count += 1

                    # 메모리 정리
                    gc.collect()

                except Exception as e:
                    print(f"      반복 {i+1} 실패: {e}")

            # 통계 계산
            if execution_times:
                avg_time = sum(execution_times) / len(execution_times)
                avg_memory = sum(memory_usages) / len(memory_usages)
                success_rate = success_count / iterations

                metric = PerformanceMetric(
                    operation=operation['name'],
                    execution_time=avg_time,
                    memory_usage=avg_memory,
                    success=success_rate > 0.8,
                    iterations=iterations
                )

                operation_metrics.append(metric)
                print(f"      평균 시간: {avg_time:.3f}초, 평균 메모리: {avg_memory:.2f}MB, 성공률: {success_rate:.1%}")

        return operation_metrics

    async def profile_react_framework(self):
        """ReAct 프레임워크 성능 프로파일링"""
        print("\n=== ReAct 프레임워크 성능 프로파일링 ===")

        react_metrics = []

        try:
            # 세션 생성 프로파일링
            start_time = time.time()
            session = await self.components['react_framework'].create_session(
                goal="성능 테스트 세션",
                max_steps=10
            )
            session_time = time.time() - start_time

            react_metrics.append(PerformanceMetric(
                operation="react_session_creation",
                execution_time=session_time,
                memory_usage=0,  # 추후 상세 측정 가능
                success=True
            ))

            # 단계별 연산 프로파일링
            steps = [
                ('think', "성능 테스트를 위한 생각"),
                ('act_web_search', {'tool': 'web_search', 'query': 'performance test'}),
                ('observe', "웹 검색 결과를 관찰했습니다"),
                ('act_file_write', {'tool': 'file_manager', 'operation': 'write', 'path': 'react_test.txt', 'content': 'test'}),
                ('reflect', "파일 작성을 완료했습니다")
            ]

            for step_name, step_data in steps:
                start_time = time.time()

                if step_name == 'think':
                    await self.components['react_framework'].think(session, step_data)
                elif step_name.startswith('act_'):
                    tool_name = step_data['tool']
                    params = {k: v for k, v in step_data.items() if k != 'tool'}
                    await self.components['react_framework'].act(session, tool_name, **params)
                elif step_name == 'observe':
                    await self.components['react_framework'].observe(session, step_data)
                elif step_name == 'reflect':
                    await self.components['react_framework'].reflect(session, step_data)

                step_time = time.time() - start_time

                react_metrics.append(PerformanceMetric(
                    operation=f"react_{step_name}",
                    execution_time=step_time,
                    memory_usage=0,
                    success=True
                ))

                print(f"   {step_name}: {step_time:.3f}초")

        except Exception as e:
            react_metrics.append(PerformanceMetric(
                operation="react_framework_error",
                execution_time=0,
                memory_usage=0,
                success=False,
                error_message=str(e)
            ))

        return react_metrics

    async def profile_memory_usage(self):
        """메모리 사용량 상세 프로파일링"""
        print("\n=== 메모리 사용량 프로파일링 ===")

        memory_metrics = []

        try:
            # 현재 메모리 스냅샷
            current, peak = tracemalloc.get_traced_memory()

            # 대용량 작업 수행
            large_operations = [
                {'name': 'large_web_search', 'iterations': 10},
                {'name': 'multiple_file_operations', 'iterations': 50},
                {'name': 'react_sessions', 'iterations': 5}
            ]

            for operation in large_operations:
                gc.collect()  # 가비지 컬렉션
                start_current, start_peak = tracemalloc.get_traced_memory()

                if operation['name'] == 'large_web_search':
                    for i in range(operation['iterations']):
                        await self.components['tool_manager'].execute_tool(
                            'web_search',
                            query=f'test query number {i}'
                        )

                elif operation['name'] == 'multiple_file_operations':
                    for i in range(operation['iterations']):
                        await self.components['tool_manager'].execute_tool(
                            'file_manager',
                            operation='write',
                            path=f'memory_test_{i}.txt',
                            content=f'content {i} ' * 100
                        )

                elif operation['name'] == 'react_sessions':
                    for i in range(operation['iterations']):
                        session = await self.components['react_framework'].create_session(
                            goal=f"메모리 테스트 {i}",
                            max_steps=3
                        )

                end_current, end_peak = tracemalloc.get_traced_memory()

                memory_metric = PerformanceMetric(
                    operation=operation['name'],
                    execution_time=0,  # 메모리 측정이므로 시간은 0
                    memory_usage=(end_current - start_current) / 1024 / 1024,  # MB
                    success=True,
                    iterations=operation['iterations']
                )

                memory_metrics.append(memory_metric)
                print(f"   {operation['name']}: {memory_metric.memory_usage:.2f}MB 증가")

        except Exception as e:
            print(f"메모리 프로파일링 오류: {e}")

        return memory_metrics

    def analyze_bottlenecks(self, all_metrics: List[PerformanceMetric]) -> List[BottleneckAnalysis]:
        """병목점 분석"""
        print("\n=== 병목점 분석 ===")

        bottlenecks = []

        # 실행 시간 기반 병목점 식별
        time_threshold = 1.0  # 1초
        memory_threshold = 50.0  # 50MB

        for metric in all_metrics:
            if not metric.success:
                bottlenecks.append(BottleneckAnalysis(
                    component=metric.operation.split('_')[0],
                    operation=metric.operation,
                    issue_type='error',
                    severity='critical',
                    impact_score=1.0,
                    recommendation=f"오류 해결 필요: {metric.error_message}",
                    estimated_improvement="오류 해결시 100% 개선"
                ))

            if metric.execution_time > time_threshold:
                severity = 'high' if metric.execution_time > 3.0 else 'medium'
                impact_score = min(metric.execution_time / 5.0, 1.0)

                bottlenecks.append(BottleneckAnalysis(
                    component=metric.operation.split('_')[0],
                    operation=metric.operation,
                    issue_type='cpu',
                    severity=severity,
                    impact_score=impact_score,
                    recommendation="비동기 처리 최적화, 캐싱 도입 검토",
                    estimated_improvement=f"{min(50, int(impact_score * 100))}% 개선 가능"
                ))

            if metric.memory_usage > memory_threshold:
                severity = 'high' if metric.memory_usage > 100.0 else 'medium'
                impact_score = min(metric.memory_usage / 200.0, 1.0)

                bottlenecks.append(BottleneckAnalysis(
                    component=metric.operation.split('_')[0],
                    operation=metric.operation,
                    issue_type='memory',
                    severity=severity,
                    impact_score=impact_score,
                    recommendation="메모리 풀링, 객체 재사용, 가비지 컬렉션 최적화",
                    estimated_improvement=f"{min(40, int(impact_score * 80))}% 메모리 절약 가능"
                ))

        # 병목점 우선순위 정렬
        bottlenecks.sort(key=lambda x: (
            {'critical': 4, 'high': 3, 'medium': 2, 'low': 1}[x.severity],
            x.impact_score
        ), reverse=True)

        if bottlenecks:
            print(f"   발견된 병목점: {len(bottlenecks)}개")
            for i, bottleneck in enumerate(bottlenecks[:5], 1):  # 상위 5개만 출력
                print(f"   {i}. [{bottleneck.severity.upper()}] {bottleneck.operation}")
                print(f"      타입: {bottleneck.issue_type}, 영향도: {bottleneck.impact_score:.2f}")
                print(f"      권장사항: {bottleneck.recommendation}")
        else:
            print("   병목점이 발견되지 않았습니다.")

        return bottlenecks

    def generate_optimization_plan(self, bottlenecks: List[BottleneckAnalysis]) -> Dict[str, Any]:
        """최적화 계획 생성"""
        print("\n=== 최적화 계획 생성 ===")

        optimization_plan = {
            'immediate_actions': [],  # 즉시 조치 사항
            'short_term_improvements': [],  # 단기 개선사항
            'long_term_strategies': [],  # 장기 전략
            'estimated_benefits': {}
        }

        # 심각도별 분류
        critical_issues = [b for b in bottlenecks if b.severity == 'critical']
        high_issues = [b for b in bottlenecks if b.severity == 'high']
        medium_issues = [b for b in bottlenecks if b.severity == 'medium']

        # 즉시 조치 사항 (critical)
        for issue in critical_issues:
            optimization_plan['immediate_actions'].append({
                'issue': issue.operation,
                'action': issue.recommendation,
                'priority': 'critical',
                'estimated_effort': 'high'
            })

        # 단기 개선사항 (high)
        for issue in high_issues:
            if issue.issue_type == 'memory':
                optimization_plan['short_term_improvements'].append({
                    'area': 'memory_optimization',
                    'actions': ['메모리 풀 구현', '객체 재사용 패턴 도입', '가비지 컬렉션 튜닝'],
                    'estimated_benefit': issue.estimated_improvement
                })
            elif issue.issue_type == 'cpu':
                optimization_plan['short_term_improvements'].append({
                    'area': 'performance_optimization',
                    'actions': ['비동기 처리 개선', '캐싱 레이어 추가', '배치 처리 도입'],
                    'estimated_benefit': issue.estimated_improvement
                })

        # 장기 전략 (medium + 전체적 개선)
        if medium_issues:
            optimization_plan['long_term_strategies'].extend([
                '성능 모니터링 시스템 구축',
                '자동 최적화 메커니즘 도입',
                '분산 처리 아키텍처 검토',
                'AI 기반 자원 관리 시스템 개발'
            ])

        # 예상 효과 계산
        total_time_improvement = sum(
            float(b.estimated_improvement.replace('%', '').replace(' 개선 가능', '').replace(' 메모리 절약 가능', ''))
            for b in bottlenecks[:3]  # 상위 3개
            if '개선' in b.estimated_improvement and '%' in b.estimated_improvement
        ) / 3

        optimization_plan['estimated_benefits'] = {
            'performance_improvement': f"{total_time_improvement:.1f}%",
            'memory_savings': "20-40%",
            'stability_increase': "95%+",
            'maintenance_reduction': "30%"
        }

        return optimization_plan

    async def generate_performance_report(self):
        """성능 보고서 생성"""
        print("\n=== 성능 보고서 생성 ===")

        # 모든 프로파일링 실행
        startup_metrics = await self.profile_component_startup()
        operation_metrics = await self.profile_tool_operations()
        react_metrics = await self.profile_react_framework()
        memory_metrics = await self.profile_memory_usage()

        all_metrics = startup_metrics + operation_metrics + react_metrics + memory_metrics

        # 병목점 분석
        bottlenecks = self.analyze_bottlenecks(all_metrics)

        # 최적화 계획 생성
        optimization_plan = self.generate_optimization_plan(bottlenecks)

        # 보고서 작성
        report = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'phase': 'Phase 9.2 - 성능 프로파일링 및 병목점 해결',
            'profiling_summary': {
                'total_operations_tested': len(all_metrics),
                'successful_operations': len([m for m in all_metrics if m.success]),
                'failed_operations': len([m for m in all_metrics if not m.success]),
                'average_execution_time': sum(m.execution_time for m in all_metrics if m.success) / len([m for m in all_metrics if m.success]) if all_metrics else 0,
                'total_memory_usage': sum(m.memory_usage for m in all_metrics if m.success),
                'bottlenecks_found': len(bottlenecks)
            },
            'detailed_metrics': {
                'startup_metrics': [
                    {
                        'operation': m.operation,
                        'execution_time': m.execution_time,
                        'memory_usage': m.memory_usage,
                        'success': m.success
                    } for m in startup_metrics
                ],
                'operation_metrics': [
                    {
                        'operation': m.operation,
                        'execution_time': m.execution_time,
                        'memory_usage': m.memory_usage,
                        'success': m.success,
                        'iterations': m.iterations
                    } for m in operation_metrics
                ],
                'react_metrics': [
                    {
                        'operation': m.operation,
                        'execution_time': m.execution_time,
                        'success': m.success
                    } for m in react_metrics
                ],
                'memory_metrics': [
                    {
                        'operation': m.operation,
                        'memory_usage': m.memory_usage,
                        'iterations': m.iterations
                    } for m in memory_metrics
                ]
            },
            'bottleneck_analysis': [
                {
                    'component': b.component,
                    'operation': b.operation,
                    'issue_type': b.issue_type,
                    'severity': b.severity,
                    'impact_score': b.impact_score,
                    'recommendation': b.recommendation,
                    'estimated_improvement': b.estimated_improvement
                } for b in bottlenecks
            ],
            'optimization_plan': optimization_plan,
            'next_phase_readiness': 'ready' if len([b for b in bottlenecks if b.severity == 'critical']) == 0 else 'needs_fixes'
        }

        return report


async def main():
    """메인 실행 함수"""
    print("PACA Phase 9.2: 성능 프로파일링 및 병목점 해결")
    print("=" * 60)

    profiler = PerformanceProfiler()

    try:
        # 1. 프로파일링 환경 설정
        if not await profiler.setup_profiling_environment():
            print("프로파일링 환경 설정 실패")
            return False

        # 2. 성능 보고서 생성
        report = await profiler.generate_performance_report()

        # 3. 결과 출력
        print(f"\n📊 성능 프로파일링 결과 요약:")
        print(f"   • 테스트한 연산: {report['profiling_summary']['total_operations_tested']}개")
        print(f"   • 성공한 연산: {report['profiling_summary']['successful_operations']}개")
        print(f"   • 실패한 연산: {report['profiling_summary']['failed_operations']}개")
        print(f"   • 평균 실행 시간: {report['profiling_summary']['average_execution_time']:.3f}초")
        print(f"   • 총 메모리 사용량: {report['profiling_summary']['total_memory_usage']:.2f}MB")
        print(f"   • 발견된 병목점: {report['profiling_summary']['bottlenecks_found']}개")

        if report['bottleneck_analysis']:
            print(f"\n🔍 주요 병목점:")
            for i, bottleneck in enumerate(report['bottleneck_analysis'][:3], 1):
                print(f"   {i}. [{bottleneck['severity'].upper()}] {bottleneck['operation']}")
                print(f"      • 타입: {bottleneck['issue_type']}")
                print(f"      • 영향도: {bottleneck['impact_score']:.2f}")
                print(f"      • 권장사항: {bottleneck['recommendation']}")

        if report['optimization_plan']['estimated_benefits']:
            print(f"\n🎯 예상 최적화 효과:")
            benefits = report['optimization_plan']['estimated_benefits']
            print(f"   • 성능 개선: {benefits.get('performance_improvement', 'N/A')}")
            print(f"   • 메모리 절약: {benefits.get('memory_savings', 'N/A')}")
            print(f"   • 안정성 향상: {benefits.get('stability_increase', 'N/A')}")

        print(f"\n🚀 다음 단계 준비 상태: {report['next_phase_readiness']}")

        # 4. 보고서 파일 저장
        report_file = "performance_report.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, ensure_ascii=False, indent=2)

        print(f"\n✅ 성능 분석 완료! 상세 보고서: {report_file}")
        return True

    except Exception as e:
        print(f"❌ 성능 분석 실패: {e}")
        import traceback
        traceback.print_exc()
        return False

    finally:
        # 메모리 추적 정리
        try:
            tracemalloc.stop()
        except:
            pass


if __name__ == "__main__":
    success = asyncio.run(main())
    sys.exit(0 if success else 1)